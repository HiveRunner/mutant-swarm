/**
 * Copyright (C) 2018-2019 Expedia, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.hotels.mutantswarm.mutate;

import static java.util.Arrays.asList;
import static java.util.Collections.emptyList;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.antlr.runtime.tree.Tree;
import org.apache.hadoop.hive.ql.lib.Node;
import org.apache.hadoop.hive.ql.parse.ASTNode;

/**
 * WARNING: This is a naive implementation. Identifies mutable elements of an abstract syntax tree generated by the
 * parser. This is a far more reliable means of identifying specific structures in queries (as it is structured), but is
 * more abstract, and contains less positional information than the lexer token stream.
 */
public class ParserMutatorStore {

  private List<Integer> mutatorList = new ArrayList<>();
  private static final Set<Integer> joinTypes = new HashSet<>();
  private static final Set<Integer> booleanTypes = new HashSet<>();
  

  public ParserMutatorStore() {
    mutatorList = asList(Vocabulary.INSTANCE.getId("EQUAL"), Vocabulary.INSTANCE.getId("NOTEQUAL"),
        Vocabulary.INSTANCE.getId("LESSTHAN"), Vocabulary.INSTANCE.getId("LESSTHANOREQUALTO"),
        Vocabulary.INSTANCE.getId("GREATERTHAN"), Vocabulary.INSTANCE.getId("GREATERTHANOREQUALTO"),
        Vocabulary.INSTANCE.getId("KW_AND"), Vocabulary.INSTANCE.getId("KW_OR"), Vocabulary.INSTANCE.getId("KW_NOT"),
        Vocabulary.INSTANCE.getId("PLUS"), Vocabulary.INSTANCE.getId("MINUS"), Vocabulary.INSTANCE.getId("STAR"),
        Vocabulary.INSTANCE.getId("DIV"), Vocabulary.INSTANCE.getId("KW_TRUE"), Vocabulary.INSTANCE.getId("KW_FALSE"),
        Vocabulary.INSTANCE.getId("Number"), Vocabulary.INSTANCE.getId("StringLiteral"),
        Vocabulary.INSTANCE.getId("Identifier"));
    
    joinTypes.addAll(Arrays.asList(Vocabulary.INSTANCE.getId("TOK_LEFTOUTERJOIN"),
        Vocabulary.INSTANCE.getId("TOK_RIGHTOUTERJOIN"), Vocabulary.INSTANCE.getId("TOK_FULLOUTERJOIN"),
        Vocabulary.INSTANCE.getId("TOK_JOIN")));
    
    booleanTypes.addAll(Arrays.asList(Vocabulary.INSTANCE.getId("KW_TRUE"),
        Vocabulary.INSTANCE.getId("KW_FALSE")));
  }

  public List<Mutator> getMutatorsFor(ASTNode tree) {
    if (!mutatorList.contains(tree.getType())) {
      return emptyList();
    }

    List<Mutator> mutators = new ArrayList<>();
    String tokenName = Vocabulary.INSTANCE.getName(tree.getType());
    switch (tokenName) {

    case "EQUAL":
      if (hasBooleanChild(tree)) {
        mutators.add(new TextReplaceMutator("Relational op EQ → NEQ '<>'", "=", "<>"));
      } else if (!insideJoin(tree)) {
        mutators.add(new TextReplaceMutator("Relational op EQ → LT '<'", "=", "<"));
        mutators.add(new TextReplaceMutator("Relational op EQ → GT '>'", "=", ">"));
        mutators.add(new TextReplaceMutator("Relational op EQ → GTE '>='", "=", ">="));
        mutators.add(new TextReplaceMutator("Relational op EQ → LTE '<='", "=", "<="));
        mutators.add(new TextReplaceMutator("Relational op EQ → NEQ '<>'", "=", "<>"));
      }
      break;

    case "NOTEQUAL":
      mutators.add(new TextReplaceMutator("Relational op NEQ → LT '<'", "<>", "<"));
      mutators.add(new TextReplaceMutator("Relational op NEQ → GT '>'", "<>", ">"));
      mutators.add(new TextReplaceMutator("Relational op NEQ → GTE '>='", "<>", ">="));
      mutators.add(new TextReplaceMutator("Relational op NEQ → LTE '<='", "<>", "<="));
      mutators.add(new TextReplaceMutator("Relational op NEQ → EQ '='", "<>", "="));
      break;

    case "LESSTHAN":
      mutators.add(new TextReplaceMutator("Relational op LT → GT '>'", "<", ">"));
      mutators.add(new TextReplaceMutator("Relational op LT → GTE '>='", "<", ">="));
      mutators.add(new TextReplaceMutator("Relational op LT → LTE '<='", "<", "<="));
      mutators.add(new TextReplaceMutator("Relational op LT → NEQ '<>'", "<", "<>"));
      mutators.add(new TextReplaceMutator("Relational op LT → EQ '='", "<", "="));
      break;

    case "LESSTHANOREQUALTO":
      mutators.add(new TextReplaceMutator("Relational op LTE → GT '>'", "<=", ">"));
      mutators.add(new TextReplaceMutator("Relational op LTE → GTE '>='", "<=", ">="));
      mutators.add(new TextReplaceMutator("Relational op LTE → LT '<'", "<=", "<"));
      mutators.add(new TextReplaceMutator("Relational op LTE → NEQ '<>'", "<=", "<>"));
      mutators.add(new TextReplaceMutator("Relational op LTE → EQ '='", "<=", "="));
      break;

    case "GREATERTHAN":
      mutators.add(new TextReplaceMutator("Relational op GT → LT '<'", ">", "<"));
      mutators.add(new TextReplaceMutator("Relational op GT → GTE '>='", ">", ">="));
      mutators.add(new TextReplaceMutator("Relational op GT → LTE '<='", ">", "<="));
      mutators.add(new TextReplaceMutator("Relational op GT → NEQ '<>'", ">", "<>"));
      mutators.add(new TextReplaceMutator("Relational op GT → EQ '='", ">", "="));
      break;

    case "GREATERTHANOREQUALTO":
      mutators.add(new TextReplaceMutator("Relational op GTE → LT '<'", ">=", "<"));
      mutators.add(new TextReplaceMutator("Relational op GTE → GT '>'", ">=", ">"));
      mutators.add(new TextReplaceMutator("Relational op GTE → LTE '<='", ">=", "<="));
      mutators.add(new TextReplaceMutator("Relational op GTE → NEQ '<>'", ">=", "<>"));
      mutators.add(new TextReplaceMutator("Relational op GTE → EQ '='", ">=", "="));
      break;

    case "KW_AND":
      mutators.add(new TextReplaceMutator("Logical Op AND → OR 'OR'", "AND", "OR"));
      break;

    case "KW_OR":
      mutators.add(new TextReplaceMutator("Logical Op OR → AND 'AND'", "OR", "AND"));
      break;

    case "KW_NOT":
      mutators.add(new TextReplaceMutator("Logical Op remove NOT ''", "NOT", ""));
      break;

    case "PLUS":
      mutators.add(new TextReplaceMutator("Op PLUS → MINUS '-'", "+", "-"));
      break;

    case "MINUS":
      mutators.add(new TextReplaceMutator("Op MINUS → PLUS '+'", "-", "+"));
      break;

    case "STAR":
      mutators.add(new TextReplaceMutator("Op MUL → DIV '/'", "*", "/"));
      break;

    case "DIV":
      mutators.add(new TextReplaceMutator("Op DIV → MUL '*'", "/", "*"));
      break;

    case "KW_FALSE":
      mutators.add(new TextReplaceMutator("BooleanLiteral FALSE → TRUE 'true'", "false", "true"));
      break;

    case "KW_TRUE":
      mutators.add(new TextReplaceMutator("BooleanLiteral TRUE → FALSE 'false'", "true", "false"));
      break;

    case "Number":
      mutators.add(new TextReplaceMutator("NumberLiteral change value: '8438749'", "?", "8438749"));
      break;

    case "StringLiteral":
      mutators.add(new TextReplaceMutator("StringLiteral change value: 'jdjfhsj'", "?", "\"jdjfhsj\""));
      break;

    case "Identifier":
      String text = tree.getText();
      if ("lower".equals(text.toLowerCase())) {
        mutators.add(new TextReplaceMutator("Identifier change value: 'upper'", "lower", "upper"));
      } else if ("upper".equals(text.toLowerCase())) {
        mutators.add(new TextReplaceMutator("Identifier change value: 'lower'", "upper", "lower"));
      }
      break;
    }
    return mutators;
  }

  private boolean insideJoin(ASTNode tree) {
    List<Tree> ancestors = (List<Tree>) tree.getAncestors();
    for (Tree node : ancestors) {
      if (joinTypes.contains(node.getType())) {
        return true;
      }
    }
    return false;
  }

  private boolean hasBooleanChild(ASTNode tree) {
    List<Node> children = tree.getChildren();
    for (Node node : children) {
      ASTNode child = (ASTNode) node;
      if (booleanTypes.contains(child.getType())) {
        return true;
      }
    }
    return false;
  }

}
